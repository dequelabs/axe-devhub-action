"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.isDirty = exports.getCommitInfo = exports.getRemoteURL = exports.parseDefaultFromShowRemoteOutput = exports.getDefaultBranchName = exports.getBranchName = exports.isRepository = void 0;
var child_process_1 = require("child_process");
/** Check if the given `dir` is contained by a Git repository. */
var isRepository = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        (0, child_process_1.execSync)('git rev-parse --is-inside-work-tree', {
            cwd: dir,
            // Prevent printing "fatal: not a git repository".
            stdio: 'ignore'
        });
        return true;
    }
    catch (_a) {
        return false;
    }
};
exports.isRepository = isRepository;
/** Get the current branch name. */
var getBranchName = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        return (0, child_process_1.execSync)('git rev-parse --abbrev-ref HEAD', {
            cwd: dir,
            // Ignore stderr to prevent printing "fatal: not a git repository" in tests.
            stdio: ['ignore', 'pipe', 'ignore']
        })
            .toString()
            .trim();
    }
    catch (_a) {
        return null;
    }
};
exports.getBranchName = getBranchName;
/** Get the default branch name. */
var getDefaultBranchName = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        var stdout = (0, child_process_1.execSync)('git remote show origin', {
            cwd: dir,
            stdio: ['ignore', 'pipe', 'ignore']
        }).toString();
        return (0, exports.parseDefaultFromShowRemoteOutput)(stdout);
    }
    catch (_a) {
        return null;
    }
};
exports.getDefaultBranchName = getDefaultBranchName;
/**
 * Parse the default branch name from the output of `git remote show origin`.
 * @private Exported only for testing.
 */
var parseDefaultFromShowRemoteOutput = function (output) {
    var match = /HEAD branch:\s(.*)/.exec(output);
    return match ? match[1].trim() : null;
};
exports.parseDefaultFromShowRemoteOutput = parseDefaultFromShowRemoteOutput;
/** Get the repository's remote URL. */
var getRemoteURL = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        return (0, child_process_1.execSync)('git config --get remote.origin.url', {
            cwd: dir,
            stdio: ['ignore', 'pipe', 'ignore']
        })
            .toString()
            .trim();
    }
    catch (_a) {
        return null;
    }
};
exports.getRemoteURL = getRemoteURL;
/** Get info on the most recent commit. */
var getCommitInfo = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        // %s=subject (message), %H=hash, %an=author name, %ae=author email, %n=newline
        // See https://git-scm.com/docs/git-show#_pretty_formats
        var stdout = (0, child_process_1.execSync)('git show --no-patch --format="%s%n%H%n%an%n%ae"', {
            cwd: dir,
            stdio: ['ignore', 'pipe', 'ignore']
        });
        var _a = stdout.toString().trim().split('\n'), message = _a[0], hash = _a[1], author = _a[2], email = _a[3];
        return { message: message, hash: hash, author: author, email: email };
    }
    catch (_b) {
        return null;
    }
};
exports.getCommitInfo = getCommitInfo;
/** Check if the repository contains unstaged changes. */
var isDirty = function (dir) {
    if (dir === void 0) { dir = process.cwd(); }
    try {
        var stdout = (0, child_process_1.execSync)('git status --short', {
            cwd: dir,
            stdio: ['ignore', 'pipe', 'ignore']
        });
        return stdout.length > 0;
    }
    catch (_a) {
        return false;
    }
};
exports.isDirty = isDirty;
//# sourceMappingURL=git.js.map